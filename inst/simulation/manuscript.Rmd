---
title: "Manuscript"
output: html_document
---

```{r initialize}
#library(devtools); install_github("statguy/Winter-Track-Counts")
library(parallel)
library(doMC)
registerDoMC(cores=detectCores())
library(WTC)
source("~/git/Winter-Track-Counts/setup/WTC-Boot.R")
library(ggplot2)
library(plyr)

context <- Context$new(resultDataDirectory=wd.data.results, processedDataDirectory=wd.data.processed, rawDataDirectory=wd.data.raw, scratchDirectory=wd.scratch, figuresDirectory=wd.figures)
scenarios <- c("A","B","C","D","E","F")
allScenarios <- c(scenarios, paste0(scenarios, "combined"), paste0(scenarios, "10days"))
modelNames <- c("SmoothModel-nbinomial-matern-ar1", "SmoothModel-nbinomial-ar1", "SmoothModelMean-nbinomial-ar1", "FMPModel")
iterations <- as.integer(c(1,1,1,1,3,1))
populationSizeOverEstimate <- 1e999

prettyScenario <- function(scenario) substr(scenario, 1, 1)
prettyModelName <- function(x) {
  lookup <- data.frame(x=modelNames, y=c("ST", "TF", "T", "FMP"), stringsAsFactors=F)
  lookup$y[match(x, lookup$x)]
}

boundaryDF <- ggplot2::fortify(FinlandWTCStudy(context=context, response="canis.lupus")$studyArea$boundary)    
```

```{r figures}
study <- getMSS(scenario=scenarios[1])$study
study$studyArea$boundary@polygons[[1]]@area / 1000^2 # Study area area
200 / (study$studyArea$boundary@polygons[[1]]@area / 1000^2) # Initial population density in Finland
intersections <- study$loadIntersections(iteration=as.integer(4))
ddply(intersections$intersections@data, .(response, year), function(x) sum(x$length) / 1000) # Total sampling effort per year (km)
#ddply(intersections$intersections@data, .(response, year), function(x) sum(x$intersections))


# Mean encounter rates
#aggrates <- data.frame()
aggrates <- ldply(allScenarios, function(scenario) {
  study <- getMSS(scenario=scenario)$study

  rates <- data.frame()
  for (iteration in 1:50) {
    intersections <- try(study$loadIntersections(iteration=as.integer(iteration)))
    if (inherits(intersections, "try-error")) next
    x <- ddply(intersections$intersections@data, .(response, year), function(x) data.frame(rate=sum(x$intersections) / (sum(x$length)/1000) / sum(x$duration)))
    rates <- rbind(rates, x)
  }
  
  y <- ddply(rates, .(year), function(x, scenario) data.frame(scenario=scenario, rate.mean=mean(x$rate), rate.sd=sd(x$rate)), scenario=scenario)
  #aggrates <- rbind(aggrates, y)
  return(y)
}, .parallel=T)

subset(aggrates, year==2020)
```

```{r figure-1-init}
#scenario <- "A"
#iterations <- as.integer(1)

i <- 1
trackData <- data.frame()
surveyRoutesData <- data.frame()

for (scenario in scenarios) {
  mss <- getMSS(scenario, nSurveyRoutes=500)
  study <- mss$study
  tracks <- study$loadTracks(iteration=iterations[i])
  intersections <- tracks$countIntersections(surveyRoutes=mss$surveyRoutes, save=F)

  
  tracks$tracks <- subset(tracks$tracks, year==2001 & yday<59)
  x <- tracks$toGGDF()
  x$scenario <- scenario
  x$observation <- F
  
  intersections$tracks$tracks <- subset(intersections$tracks$tracks, year==2001)
  y <- intersections$tracks$toGGDF()
  y$scenario <- scenario
  y$observation <- T
  levels(y$group) <- paste(levels(y$group), "2")
  trackData <- rbind(trackData, x, y)
  
  
  x <- intersections$surveyRoutes$toGGDF()
  x$scenario <- scenario    
  observedAt <- intersections$intersections$intersections[intersections$intersections$intersections$intersections > 0 & intersections$intersections$intersections$year == 2001,]$surveyRoute
  y <- data.frame(id=unique(x$id), observation=FALSE)
  if (length(observedAt) > 0) y[y$id %in% observedAt,]$observation <- TRUE
  x <- plyr::join(x, y, by="id")
  surveyRoutesData <- rbind(surveyRoutesData, x)
    
  
  #trackData$type <- "track"
  #surveyRoutesData$type <- "transect"
  #x <- rbind(trackData[,c("long","lat","order","piece","group","observation","type")], surveyRoutesData[,c("long","lat","order","piece","group","observation","type")])
  #x$colour <- factor(paste(x$type, x$observation))
  #ggplot(x, aes(long, lat, group=group, colour=colour)) + geom_path()

  
  i <- i + 1
}

trackData$scenario <- factor(trackData$scenario)
```

```{r figure-1}
#window <- c(3.375, 3.4, 6.9, 6.925)*1e6
window <- (c(3.425, 3.45, 6.95, 6.975)+c(-.01,.01,-.01,.01)*9)*1e6
habitatRaster <- crop(study$studyArea$habitat, extent(window))
z <- sampleRegular(habitatRaster, 10000, asRaster=TRUE)
habitatData <- as.data.frame(rasterToPoints(z))
#habitatData <- as.data.frame(rasterToPoints(habitatRaster))
colnames(habitatData) <- c("x","y","z")
habitatData$scenario <- factor("E", levels=scenarios)
habitatData2 <- habitatData
habitatData2$scenario <- factor("F", levels=scenarios)
habitatData <- rbind(habitatData, habitatData2)

habitatData$z <- factor(habitatData$z, levels=0:255)
col <- study$studyArea$habitat@legend@colortable
names(col) <- 0:255

p <- ggplot(habitatData) + geom_raster(aes(x, y, fill=z), alpha=.4) + scale_fill_manual(values=col) +
  geom_path(data=trackData, aes(long, lat, group=group, colour=observation), alpha=1, size=.3) +#, alpha=observation)) +
  scale_colour_manual(values=c("gray55","black")) + # scale_alpha_manual(values=c(.5,1)) + # gray40
  geom_path(data=surveyRoutesData, aes(long, lat, group=group), size=.3, colour="blue", alpha=.5) +
  coord_fixed(ratio=1, xlim=window[1:2], ylim=window[3:4]) +
  facet_wrap(~scenario) + #coord_equal()
  theme_raster(base_size=10) + theme(panel.border=element_rect(fill="transparent"))
#print(p)
saveFigure(p, "manuscript-figure-1.png", width=8, height=5)

# scale on the map in km
c((window[2]-window[1]), (window[4]-window[3]))/1000
```

```{r figure-1-separate, eval=FALSE}
getRaster <- function(habitatRaster, xlim, ylim, size=10000) {
  x <- crop(habitatRaster, extent(c(xlim, ylim)))
  y <- sampleRegular(x, size=size, asRaster=TRUE)
  habitatData <- as.data.frame(rasterToPoints(y))
  colnames(habitatData) <- c("x","y","z")
  habitatData$z <- factor(habitatData$z, levels=0:255)
  col <- habitatRaster@legend@colortable
  names(col) <- 0:255
  return(habitatData)
}

getPanel <- function(scenario, xlim=c(3.375,3.4)*1e6, ylim=c(6.9,6.925)*1e6, habitatRaster, trackData, surveyRoutesData) {
  s <- scenario
  p <- if (!missing(habitatRaster)) {
    habitatData <- getRaster(habitatRaster=habitatRaster, xlim=xlim, ylim=ylim)
    ggplot(habitatData) + geom_raster(aes(x, y, fill=z)) + scale_fill_manual(values=col) +
      geom_path(data=subset(trackData, scenario==s), aes(long, lat, group=group, colour=observation))
  }
  else {
     ggplot(subset(trackData, scenario==s)) +
       geom_path(aes(long, lat, group=group, colour=observation))
  }
  
  p <- p + scale_colour_manual(values=c("gray40","black")) +
    geom_path(data=subset(surveyRoutesData, scenario==s), aes(long, lat, group=group)) +
    coord_fixed(ratio=1, xlim=xlim, ylim=ylim) +
    theme_raster(base_size=10, panel.border=element_rect(fill="transparent"), plot.title=element_text(size=12)) +
    ggtitle(s)

  return(p)
}

library(gridExtra)

p1 <- getPanel(scenario="A", trackData=trackData, surveyRoutesData=surveyRoutesData)
p2 <- getPanel(scenario="B", trackData=trackData, surveyRoutesData=surveyRoutesData)
p3 <- getPanel(scenario="C", trackData=trackData, surveyRoutesData=surveyRoutesData)
p4 <- getPanel(scenario="D", trackData=trackData, surveyRoutesData=surveyRoutesData)
p5 <- getPanel(scenario="E", habitatRaster=study$studyArea$habitat, trackData=trackData, surveyRoutesData=surveyRoutesData)
p6 <- getPanel(scenario="F", habitatRaster=study$studyArea$habitat, trackData=trackData, surveyRoutesData=surveyRoutesData)
p <- arrangeGrob(p1, p2, p3, p4, p5, p6, ncol=3, nrow=2)
saveFigure(p, "manuscript-figure-1.png")
```


```{r, eval=F}
#x<-data.frame(scenario="C", iteration=as.integer(3), stringsAsFactors=F)
modelName <- modelNames[2]
x<-data.frame(scenario="A", iteration=as.integer(10), stringsAsFactors=F)
study <- getStudy(scenario=x$scenario)
estimates <- study$getModel(modelName=modelName, iteration=x$iteration)
estimates$modelName <- modelName
estimates <- study$loadEstimates(estimates)
intersections <- study$loadIntersections(iteration=x$iteration)
head(subset(intersections$intersections@data, intersections>0), 20)
head(subset(estimates$data, intersections>0), 20)


model <- SimulatedSmoothModelTemporal(study=study, iteration=as.integer(1))
params <- list(family="nbinomial", offsetScale=1000^2, timeModel="ar1")
intersections <- study$loadIntersections(iteration = model$iteration)
model$setup(intersections = intersections, params = params)
model$estimate()

head(subset(model$data, intersections>0), 20)
head(subset(intersections$intersections@data, intersections>0), 20)


./count_intersections.sh ~/git/RParallelScreen/ A 1 1 1
./estimate.sh ~/git/RParallelScreen/ A 1 1 SmoothModel-nbinomial-ar1

./estimate.sh ~/git/RParallelScreen/ A 1 1 FMPModel

```

```{r figure-2-init}
getSurveyRouteLocations = function(scenarios, modelName, iterations, years) {
  ddply(data.frame(scenario=scenarios, iteration=iterations, stringsAsFactors=FALSE), .(scenario, iteration), function(x, modelName, years) {
    message("Scenario = ", x$scenario, ", iteration = ", x$iteration)
    study <- getStudy(scenario=x$scenario)
    estimates <- study$getModel(modelName=modelName, iteration=x$iteration) 
    estimates$modelName <- modelName
    estimates <- study$loadEstimates(estimates)
    z <- cbind(estimates$getUnscaledObservationCoordinates(), estimates$data)
    surveyRoutes <- subset(z, year %in% years, select=c(x,y,intersections))
    surveyRoutes$intersections <- surveyRoutes$intersections > 0
    surveyRoutes$Scenario <- x$scenario
    surveyRoutes$Iteration <- x$iteration
    return(surveyRoutes)
  }, modelName=modelName, years=years)
}

#x<-data.frame(scenario="C", iteration=as.integer(3), stringsAsFactors=F)
getAgentLocations = function(scenarios, modelName, iterations, years) {
  ddply(data.frame(scenario=scenarios, iteration=iterations, stringsAsFactors=FALSE), .(scenario, iteration), function(x, modelName, years) {

    #study <- getStudy(scenario=x$scenario)
    #intersections <- study$loadIntersections(iteration=x$iteration)
    #observationTracks <- SimulatedTracks$new(study=study, iteration=x$iteration)
    #observationTracks$loadTracks(fileName=observationTracks$getObservationTracksFileName(), addColumns=TRUE)
    # TODO: use observation tracks ^^^^
    
    
    
    study <- getStudy(scenario=x$scenario)
    tracks <- study$loadTracks(iteration=x$iteration)
    tracks$tracks <- subset(tracks$tracks, year %in% years & yday<59)
    intersections <- study$loadIntersections(iteration=x$iteration)
    
    # The observation day has not been recorded, ouch... just randomize a day from the 60 days track
    observedBursts <- aaply(intersections$intersectionsMatrix, 2, function(x) if (any(x>0)) TRUE else FALSE)
    #observationTracks <- tracks$randomizeObservationDayTracks(days=1)
    observationTracks <- tracks
    
    #d_ply(observationTracks$tracks, .(id, year, burst), function(x) {
    #  with(x[1,], message(id, " ", year, " ", burst))
    #})
    
    # Return mean location of the unobserved agents
    a <- ddply(observationTracks$tracks, .(id, year, burst), function(x, observedBursts) {
      name <- with(x[1,], paste(id, year, burst))
      if (observedBursts[name] == FALSE) return(data.frame(x=mean(x$x), y=mean(x$y), year=x$year[1]))
      #if (observedBursts[name] == FALSE) return(data.frame(x=x$x, y=x$y, year=x$year))
      NULL
    }, observedBursts=observedBursts)[,c("x","y","year")]
    a$Observed <- F
    
    # But for the observed agents we know the location, which is the transect
    index <- intersections$intersections$intersections > 0 & intersections$intersections$year %in% years
    b <- if (all(index == FALSE)) data.frame() else {
      x <- intersections$intersections[index,]
      y <- data.frame(coordinates(x), year=x$year)
      y$Observed <- T
      y
    }
    
    agentLocations <- rbind(a, b)
    agentLocations$Scenario <- x$scenario
    agentLocations$Model <- x$modelName
    
    return(agentLocations)
  }, modelName=modelName, years=years)
}

getEstimatedDensity = function(scenarios, modelName, iterations, year, sd=FALSE, log=FALSE) {
  ddply(data.frame(scenario=scenarios, year=rep(year, scenarios), iteration=iterations, stringsAsFactors=FALSE), .(scenario, iteration), function(x, modelName, sd) {
    message("Scenario = ", x$scenario, ", iteration = ", x$iteration)
    study <- getStudy(scenario=x$scenario)
    estimates <- study$getModel(modelName=modelName, iteration=x$iteration)
    estimates$modelName <- modelName
    estimates <- study$loadEstimates(estimates)
    estimates$collectEstimates()
    
    studyArea <- FinlandStudyArea$new(context=context)$setup(tolerance=0.001)
    
    estimates$data <- subset(estimates$data, year == x$year)
    #if (log) estimates$data$fittedMean <- log(estimates$data$fittedMean)
    density <- estimates$getPopulationDensityInterpolate(getSD=sd, maskPolygon=studyArea$boundary)
    density <- if (sd) density$sd else density$mean
    if (is.null(density) || maxValue(density$rasterStack[[1]]) > 1) stop("Estimation failed.")
    density <- as.data.frame(density$rasterStack[[1]], xy=T)
    density$Scenario <- x$scenario
    density$Iteration <- x$iteration
    density$Model <- modelName
    density$Year <- year0

    return(density)
  }, modelName=modelName, sd=sd)
}
```

```{r figure-2}
study <- getStudy(scenario="A")
limits <- extent(study$studyArea$boundary)
iterations <- as.integer(c(1,6,3,2,5,31))
year <- 2010
yearLayer <- paste0("X", year)
surveyRoutes <- getSurveyRouteLocations(scenarios=scenarios, modelName=modelNames[1], iterations=iterations, years=year)
#surveyRoutes <- rbind(surveyRoutes[surveyRoutes$intersections == FALSE,], surveyRoutes[surveyRoutes$intersections == TRUE,])
agents <- getAgentLocations(scenarios=scenarios, modelName=modelNames[1], iterations=iterations, years=year)
densities <- getEstimatedDensity(scenarios=scenarios, modelName=modelNames[1], iterations=iterations, year=year, sd=F, log=F)
# TODO: do not use scaling??
#densitiesScaled <- ddply(densities, .(scenario), function(x, yearLayer) { x[,yearLayer] <- scale(x[,yearLayer]); return(x) }, yearLayer=yearLayer)

# Scale density to 1/km^2
densitiesScaled <- ddply(densities, .(scenario), function(x, yearLayer, weight, logTrans) {
  x[,yearLayer] <- x[,yearLayer] * weight
  if (logTrans) x[,yearLayer] <- log(x[,yearLayer])
  return(x)
}, yearLayer=yearLayer, weight=1 / (prod(res(study$getTemplateRaster())) / 1000^2), logTrans=F)

p <- ggplot(densitiesScaled) + geom_raster(aes_string(x="x", y="y", fill=yearLayer)) +
  scale_fill_gradientn(colours=terrain.colors(100), na.value="transparent", guide=guide_legend(title=expression(paste("Population density ", (individuals/km^2))))) +
  geom_path(data=boundaryDF, aes(long, lat, group=group), colour="darkgreen") +
  geom_point(data=agents, aes(x, y, colour=Observed), size=1.3, colour="white") +
  geom_point(data=agents, aes(x, y, colour=Observed), size=1) + scale_color_manual(values=c("darkgray", "black"), guide=FALSE) +
  scale_x_continuous(limits=c(limits@xmin, limits@xmax), expand=c(0,0)) +
  scale_y_continuous(limits=c(limits@ymin, limits@ymax), expand=c(0,0)) +
  facet_grid(~scenario) + coord_equal() + theme_raster(base_size=10) + theme(legend.position="bottom")
print(p)
saveFigure(p, "manuscript-figure-2a.png", width=6,height=3)

###

gridTemplate <- raster(extent(study$studyArea$boundary), nrows=12, ncols=6, crs=study$studyArea$proj4string)
gridTemplate@extent@xmax <- gridTemplate@extent@xmin + dim(gridTemplate)[2] * 100 * 1e3
gridTemplate@extent@ymax <- gridTemplate@extent@ymin + dim(gridTemplate)[1] * 100 * 1e3

p <- ggplot(boundaryDF) + geom_path(aes(long, lat, group=group), colour="grey") +
  geom_point(data=surveyRoutes, aes(x, y, colour=intersections), size=1) + scale_color_manual(values=c("darkgrey", "black")) +
  scale_x_continuous(breaks=seq(gridTemplate@extent@xmin, gridTemplate@extent@xmax, 1e5), expand=c(0,0)) +
  scale_y_continuous(breaks=seq(gridTemplate@extent@ymin, gridTemplate@extent@ymax, 1e5), expand=c(0,0)) +
  facet_grid(~scenario) + theme_raster(base_size=10) + coord_equal() + theme(panel.grid.major=element_line(colour="grey"))
print(p)
saveFigure(p, "manuscript-figure-2b.png", width=6,height=3)
```

```{r figure-3-init}
getIntersections <- function(scenarios) {
  study <- getStudy(scenario="A")
  validation <- Validation(study=study)
  intersections <- validation$getValidationTemporalIntersections(scenarios=scenarios)
  intersections$Year <- intersections$year
  intersections
}

getPopulationSizes <- function(scenarios, modelNames, populationSizeOverEstimate=Inf) {
  study <- getStudy(scenario="A") # Get study object, scenario doesn't matter
  validation <- Validation(study=study, populationSizeOverEstimate=populationSizeOverEstimate)
  populationSizes <- validation$getValidationTemporalPopulationSizes(scenarios=scenarios, modelNames=modelNames)
  #validation$summarizePopulationSize(populationSizes)  
}

getMeanPopulationSizes <- function(populationSizes) {
  meanPopulationSizes <- ddply(populationSizes, .(scenario, modelName), function(x) {
    x <- data.frame(True=mean(x$Observed), Estimated=mean(x$Estimated), Scenario=x$scenario[1])
    if (is.infinite(x$True)) x$True <- NA
    if (is.infinite(x$Estimated)) x$Estimated <- NA
    return(x)
  })
  return(meanPopulationSizes)
}

getLogPopulationSizes <- function(populationSizes) {
  logPopulationSizes <- populationSizes
  logPopulationSizes$Observed <- log10(logPopulationSizes$Observed + 1)
  logPopulationSizes$Estimated <- log10(logPopulationSizes$Estimated + 1)
  return(logPopulationSizes)
}

plotLogPopulationSize <- function(size, meanSize, modelName, xlim, ylim) {
  library(ggplot2)
  library(scales)  
  size$Scenario <- prettyScenario(size$Scenario)
  meanSize$Scenario <- prettyScenario(meanSize$Scenario)
  
  p <- ggplot(size, aes(Observed, Estimated, colour=modelName)) +
    geom_point(size=1, colour="darkgray", alpha=.25) +
    geom_abline(colour="black", linetype="longdash") + 
    geom_point(data=meanSize, aes(True, Estimated), size=2, shape=15, colour="black")

  #if (!any(abs(size$Estimated) == Inf)) p <- p + geom_smooth(method="lm", se=F, fullrange=T, colour="black")
  ls <- ddply(size, .(Scenario), function(x) if (!any(abs(x$Estimated) == Inf)) coef(lm(Estimated~Observed, x)) else c(NA,NA))
  p <- p + geom_abline(data=ls, aes(intercept=`(Intercept)`, slope=Observed))
  
  p <- p + facet_wrap(~Scenario) +
    scale_x_continuous(limits=xlim, labels=trans_format("identity", math_format(10^.x))) +
    scale_y_continuous(limits=ylim, labels=trans_format("identity", math_format(10^.x))) +
    xlab("True population size") + ylab("Estimated population size") + ggtitle(paste("Model: ", prettyModelName(modelName[1]))) +
    theme_minimal(base_size=10) + theme(panel.border=element_rect(fill="transparent"), legend.title=element_text(size=12))

  print(p)
  return(p)
}
```

```{r figure-3-init-2-test, eval=FALSE}
populationSizes <- getPopulationSizes(scenarios=scenarios[1:4], modelNames=modelNames[3:4])
populationSizes2000 <- getPopulationSizes(scenarios=paste0(scenarios[1:4], "combined"), modelNames=modelNames[3:4])
populationSizes10Days <- getPopulationSizes(scenarios=paste0(scenarios[1:4], "10days"), modelNames=modelNames[3:4])
```

```{r figure-3-init-2}
registerDoMC(cores=10) # The nodes seem to run out of memory and fail with a bogus error message, so it's better to reduce the number of used cores.
populationSizes <- getPopulationSizes(scenarios=scenarios, modelNames=modelNames)
populationSizes2000 <- getPopulationSizes(scenarios=paste0(scenarios, "combined"), modelNames=modelNames)
populationSizes10Days <- getPopulationSizes(scenarios=paste0(scenarios, "10days"), modelNames=modelNames)
registerDoMC(cores=detectCores())

meanPopulationSizes  <- getMeanPopulationSizes(populationSizes)
logPopulationSizes <- getLogPopulationSizes(populationSizes)
logMeanPopulationSizes  <- getMeanPopulationSizes(logPopulationSizes)

meanPopulationSizes2000  <- getMeanPopulationSizes(populationSizes2000)
logPopulationSizes2000 <- getLogPopulationSizes(populationSizes2000)
logMeanPopulationSizes2000  <- getMeanPopulationSizes(logPopulationSizes2000)

meanPopulationSizes10Days  <- getMeanPopulationSizes(populationSizes10Days)
logPopulationSizes10Days <- getLogPopulationSizes(populationSizes10Days)
logMeanPopulationSizes10Days  <- getMeanPopulationSizes(logPopulationSizes10Days)
```

```{r figure-3abc}
#modelNames <- modelNames[c(2:4,1)]

xlim <- log10(10^c(0,4)); ylim <- xlim
p <- plotLogPopulationSize(subset(logPopulationSizes, modelName==modelNames[1]), subset(logMeanPopulationSizes, modelName==modelNames[1]), modelName=modelNames[1], xlim=xlim, ylim=ylim)
saveFigure(p, "manuscript-figure-3a1.png", width=8, height=4)
p <- plotLogPopulationSize(subset(logPopulationSizes, modelName==modelNames[2]), subset(logMeanPopulationSizes, modelName==modelNames[2]), modelName=modelNames[2], xlim=xlim, ylim=ylim)
saveFigure(p, "manuscript-figure-3a2.png", width=8, height=4)
p <- plotLogPopulationSize(subset(logPopulationSizes, modelName==modelNames[3]), subset(logMeanPopulationSizes, modelName==modelNames[3]), modelName=modelNames[3], xlim=xlim, ylim=ylim)
saveFigure(p, "manuscript-figure-3a3.png", width=8, height=4)

xlim <- log10(10^c(2,4)); ylim <- xlim
p <- plotLogPopulationSize(subset(logPopulationSizes2000, modelName==modelNames[1]), subset(logMeanPopulationSizes2000, modelName==modelNames[1]), modelName=modelNames[1], xlim=xlim, ylim=ylim)
saveFigure(p, "manuscript-figure-3b1.png", width=8, height=4)
p <- plotLogPopulationSize(subset(logPopulationSizes2000, modelName==modelNames[2]), subset(logMeanPopulationSizes2000, modelName==modelNames[2]), modelName=modelNames[2], xlim=xlim, ylim=ylim)
saveFigure(p, "manuscript-figure-3b2.png", width=8, height=4)
p <- plotLogPopulationSize(subset(logPopulationSizes2000, modelName==modelNames[3]), subset(logMeanPopulationSizes2000, modelName==modelNames[3]), modelName=modelNames[3], xlim=xlim, ylim=ylim)
saveFigure(p, "manuscript-figure-3b3.png", width=8, height=4)

xlim <- log10(10^c(0,4)); ylim <- xlim
p <- plotLogPopulationSize(subset(logPopulationSizes10Days, modelName==modelNames[1]), subset(logMeanPopulationSizes10Days, modelName==modelNames[1]), modelName=modelNames[1], xlim=xlim, ylim=ylim)
saveFigure(p, "manuscript-figure-3c1.png", width=8, height=4)
p <- plotLogPopulationSize(subset(logPopulationSizes10Days, modelName==modelNames[2]), subset(logMeanPopulationSizes10Days, modelName==modelNames[2]), modelName=modelNames[2], xlim=xlim, ylim=ylim)
saveFigure(p, "manuscript-figure-3c2.png", width=8, height=4)
p <- plotLogPopulationSize(subset(logPopulationSizes10Days, modelName==modelNames[3]), subset(logMeanPopulationSizes10Days, modelName==modelNames[3]), modelName=modelNames[3], xlim=xlim, ylim=ylim)
saveFigure(p, "manuscript-figure-3c3.png", width=8, height=4)
```

```{r table-1abc}
getPopulationSizesTable <- function(populationSizes, meanPopulationSizes, overEstimate, full=F, file, ...) {
  library(plyr)
  x <- ddply(populationSizes, .(Scenario, modelName), function(x, overEstimate) {
    failed <- round((sum(x$Estimated >= overEstimate) / nrow(x)) * 100)
    if (any(abs(x$Estimated) == Inf)) return(data.frame(Intercept=NA, Slope=NA, R2=NA, Failed=failed, MeanProp=NA, SDProp=NA))
    y <- lm(Estimated~Observed, x)
    prop.mean <- mean(x$Estimated/x$Observed)
    prop.sd <- sd(x$Estimated/x$Observed)
    return(data.frame(Intercept=round(coef(y)[1], 0), Slope=round(coef(y)[2], 2), R2=round(summary(y)$r.squared, 2), Failed=failed, MeanProp=prop.mean, SDProp=prop.sd))
  }, overEstimate=overEstimate)
  
  y <- unique(meanPopulationSizes)
  y$Scenario <- y$scenario
  #y$EstDev <- y$Estimated / y$True
  z <- plyr::join(x, y)
  z$Model <- prettyModelName(z$modelName)
  z$Scenario <- substr(z$Scenario, 1, 1)
  if (full) return(z)
  
  z <- z[,c("Scenario","Model","Slope","R2","Failed","MeanProp","SDProp")]
  #z$EstDev <- round(z$EstDev, 2)
  z$MeanProp <- round(z$MeanProp, 2)
  z$SDProp <- round(z$SDProp, 2)
  if (!missing(file)) write.csv(z, file=file)
  return(z)
}

table1 <- getPopulationSizesTable(populationSizes, meanPopulationSizes, overEstimate=2000)
logTable1 <- getPopulationSizesTable(logPopulationSizes, logMeanPopulationSizes, overEstimate=log10(2000+1))
logTable1$MeanProp <- table1$MeanProp; logTable1$SDProp <- table1$SDProp; 

table2 <- getPopulationSizesTable(populationSizes2000, meanPopulationSizes2000, overEstimate=20000)
logTable2 <- getPopulationSizesTable(logPopulationSizes2000, logMeanPopulationSizes2000, overEstimate=log10(20000+1))
logTable2$MeanProp <- table2$MeanProp; logTable2$SDProp <- table2$SDProp; 

table3 <- getPopulationSizesTable(populationSizes10Days, meanPopulationSizes10Days, overEstimate=2000)
logTable3 <- getPopulationSizesTable(logPopulationSizes10Days, logMeanPopulationSizes10Days, overEstimate=log10(2000+1))
logTable3$MeanProp <- table3$MeanProp; logTable3$SDProp <- table3$SDProp; 

dir <- normalizePath(context$figuresDirectory)
write.csv(logTable1, file=file.path(dir, "table-1a.csv"))
write.csv(logTable2, file=file.path(dir, "table-2a.csv"))
write.csv(logTable3, file=file.path(dir, "table-3a.csv"))
```

```{r table-2}
intersections <- getIntersections(scenarios)
intersections2000 <- getIntersections(scenarios=paste0(scenarios, "combined"))
intersections10days <- getIntersections(scenarios=paste0(scenarios, "10days"))
intersections <- plyr::join(populationSizes, intersections)
intersections2000 <- plyr::join(populationSizes2000, intersections2000)
intersections10days <- plyr::join(populationSizes10Days, intersections10days)
i.stat <- function(x) data.frame(i.mean=round(mean(x$intersections/x$Observed),2), i.sd=round(sd(x$intersections/x$Observed),2))
ddply(intersections, .(Scenario), i.stat)
ddply(intersections2000, .(Scenario), i.stat)
ddply(intersections10days, .(Scenario), i.stat)
```

```{r figure-4-init}
getPopulationCorrelations <- function(scenarios, modelNames) {
  study <- getStudy(scenario="A")
  validation <- Validation(study=study, populationSizeOverEstimate=Inf)
  populationCorrelations <- validation$getValidationSpatialPopulationSizes(scenarios=scenarios, modelNames=modelNames)
  return(populationCorrelations)
}

plotPopulationCorrelations <- function(populationCorrelations) {
  p <- ggplot(populationCorrelations, aes(True, Correlation)) + geom_point(size=1, colour="black") +
  facet_wrap(~Scenario, ncol=2) + xlab("True population size") +
  theme_minimal(base_size=10) + theme(panel.border=element_rect(fill="transparent"))#, axis.text.x=element_text(angle=45, hjust=.5, vjust=1))
  return(p)
}
```

```{r figure-4abc}
pc1 <- getPopulationCorrelations(scenarios=scenarios, modelNames=modelNames[1])
pc2 <- getPopulationCorrelations(scenarios=paste0(scenarios, "combined"), modelNames=modelNames[1])
pc3 <- getPopulationCorrelations(scenarios=paste0(scenarios, "10days"), modelNames=modelNames[1])

p1 <- plotPopulationCorrelations(pc1)
saveFigure(p1, "manuscript-figure-4a.png", width=4, height=4)
p2 <- plotPopulationCorrelations(pc2)
saveFigure(p2, "manuscript-figure-4b.png", width=4, height=4)
p3 <- plotPopulationCorrelations(pc3)
saveFigure(p3, "manuscript-figure-4c.png", width=4, height=4)
```


```{r figure-5-init}
getCIProportions <- function(scenarios, modelNames, panel, scenarioNames) {
  study <- getStudy(scenario="A")
  validation <- Validation(study=study, populationSizeOverEstimate=Inf)
  a <- validation$getValidatedCredibilityIntervalsProportions(scenarios=scenarios, modelNames=modelNames)
  b <- validation$getValidatedCredibilityIntervalsProportions(scenarios=scenarios, modelNames=modelNames, probs=c(.25, .75), probsName="50%")
  credibilityIntervals <- rbind(a, b)
  credibilityIntervals$panel <- panel
  credibilityIntervals$scenario <- rep(scenarioNames, times=2, each=2)
  return(credibilityIntervals)  
}

plotCIProportions <- function(credibilityIntervals) {
  credibilityIntervals$CI <- credibilityIntervals$Interval
  p <- ggplot(credibilityIntervals, aes(scenario, Proportion, shape=CI, colour=modelName)) +
    geom_hline(aes(yintercept=.5), color="grey90") +
    geom_hline(aes(yintercept=.95), color="grey90") +
    geom_point() +
    scale_shape_manual(values=c(16, 1)) + scale_colour_manual("Model", values=c("darkgray", "black"), labels=c("T", "ST")) +
    theme_minimal(base_size=10) + theme(panel.border=element_rect(fill="transparent")) +
    xlab("Scenario") + ylab("Proportion within CI") +
    facet_wrap(~panel) + ylim(0, 1) +
    theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank())
  return(p)
}
```

```{r figure-5abc}
cip1 <- getCIProportions(scenarios=scenarios, modelNames=modelNames, panel="a", scenarioNames=scenarios)
cip2 <- getCIProportions(scenarios=paste0(scenarios, "combined"), modelNames=modelNames, panel="b", scenarioNames=scenarios)
cip3 <- getCIProportions(scenarios=paste0(scenarios, "10days"), modelNames=modelNames, panel="c", scenarioNames=scenarios)
cip <- rbind(cip1, cip2, cip3)
p <- plotCIProportions(cip)
saveFigure(p, "manuscript-figure-5.png", width=6, height=2)

#p1 <- plotCIProportions(cip1)
#saveFigure(p1, "manuscript-figure-5a.png", width=4, height=2)
#p2 <- plotCIProportions(cip2)
#saveFigure(p2, "manuscript-figure-5b.png", width=4, height=2)
#p3 <- plotCIProportions(cip3)
#saveFigure(p3, "manuscript-figure-5c.png", width=4, height=2)
```
