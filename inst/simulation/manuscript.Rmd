---
title: "Manuscript"
output: html_document
---

```{r initialize}
#library(devtools); install_github("statguy/Winter-Track-Counts")
library(parallel)
library(doMC)
registerDoMC(cores=detectCores())
library(WTC)
source("~/git/Winter-Track-Counts/setup/WTC-Boot.R")
library(ggplot2)
library(scales)
library(grid)
library(plyr)

context <- Context$new(resultDataDirectory=wd.data.results, processedDataDirectory=wd.data.processed, rawDataDirectory=wd.data.raw, scratchDirectory=wd.scratch, figuresDirectory=wd.figures)
scenarios <- c("A","B","C","D","E","F")
allScenarios <- c(scenarios, paste0(scenarios, "combined"), paste0(scenarios, "10days"))
modelNames <- c("SmoothModel-nbinomial-matern-ar1", "SmoothModel-nbinomial-ar1", "SmoothModelMean-nbinomial-ar1", "FMPModel", "SmoothModelMean-nbinomial-ar1-priors1")
iterations <- as.integer(c(1,1,1,1,3,1))
#populationSizeOverEstimate <- 1e999

prettyScenario <- function(scenario) substr(scenario, 1, 1)
prettyModelName <- function(x) {
  lookup <- data.frame(x=modelNames, y=c("ST", "VT", "T1", "FMP", "T2"), stringsAsFactors=F)
  lookup$y[match(x, lookup$x)]
}

boundaryDF <- ggplot2::fortify(FinlandWTCStudy(context=context, response="canis.lupus")$studyArea$boundary)

```

```{r figures}
study <- getMSS(scenario=scenarios[1])$study
study$studyArea$boundary@polygons[[1]]@area / 1000^2 # Study area area
200 / (study$studyArea$boundary@polygons[[1]]@area / 1000^2) # Initial population density in Finland
intersections <- study$loadIntersections(iteration=as.integer(4))
ddply(intersections$intersections@data, .(response, year), function(x) sum(x$length) / 1000) # Total sampling effort per year (km)
#ddply(intersections$intersections@data, .(response, year), function(x) sum(x$intersections))


# Mean encounter rates
#aggrates <- data.frame()
aggrates <- ldply(allScenarios, function(scenario) {
  study <- getMSS(scenario=scenario)$study

  rates <- data.frame()
  for (iteration in 1:50) {
    intersections <- try(study$loadIntersections(iteration=as.integer(iteration)))
    if (inherits(intersections, "try-error")) next
    x <- ddply(intersections$intersections@data, .(response, year), function(x) data.frame(rate=sum(x$intersections) / (sum(x$length)/1000) / sum(x$duration)))
    rates <- rbind(rates, x)
  }
  
  y <- ddply(rates, .(year), function(x, scenario) data.frame(scenario=scenario, rate.mean=mean(x$rate), rate.sd=sd(x$rate)), scenario=scenario)
  #aggrates <- rbind(aggrates, y)
  return(y)
}, .parallel=T)

subset(aggrates, year==2020)

###

library(raster)
mss <- getMSS("E")
study <- mss$study
surveyRoutes <- mss$getSurveyRoutes()
#habitatTypes <- raster::extract(habitat, surveyRoutes$surveyRoutes[1:3])

study$studyArea$readRasterIntoMemory()
habitat <- study$studyArea$habitat
habitatTypes <- raster::extract(habitat, surveyRoutes$surveyRoutes)
habitatWeights <- CORINEHabitatWeights$new()
      
forestProportions <- c()
for (i in seq_along(habitatTypes)) {
  classifiedHabitatTypes <- habitatWeights$classify(habitatTypes[[i]]) == 3 # Forest
  forestProportions <- c(forestProportions, sum(classifiedHabitatTypes) / length(classifiedHabitatTypes))
}

#mean(forestProportion)
sum(forestProportion * surveyRoutes$lengths) / sum(surveyRoutes$lengths) # = 0.9404947

###

study$studyArea$boundary@polygons[[1]]@area
habitatCut <- raster::mask(habitat, study$studyArea$boundary)
habitatWeights <- CORINEHabitatWeights$new(study=study)
habitatFreq <- freq(habitatCut, progress="text")
x <- habitatFreq

p <- c()
for (i in 1:50) {
  habitatPreferences <- HabitatSelection$new(study=study, iteration=as.integer(i))
  fileName <- habitatPreferences$getHabitatSelectionFileName()
  habitatSelection <- try(habitatPreferences$loadHabitatSelection())
  if (inherits(habitatSelection, "try-error")) next
  habitatWeights$setHabitatSelectionWeights(habitatSelection)
  
  y <- subset(habitatWeights$weights, habitat %in% x[,1])
  effectiveArea <- sum(y$weight * x[,2]) * prod(res(habitat))
  fullArea <- sum(x[-nrow(x),]) * prod(res(habitat))
  
  p <- c(p, effectiveArea / fullArea)
}
mean(1/p) # = 1.286095

p <- c()
for (i in 1:50) {
  estimates <- study$getModel(modelName=modelNames[4], iteration=as.integer(i))
  popsize <- try(study$getPopulationSize(estimates=estimates, save=FALSE))
  if (inherits(popsize, "try-error")) next
  p <- c(p, popsize$sizeData$Estimated)
}


```

```{r figure-1-init}
#scenario <- "A"
#iterations <- as.integer(1)

i <- 1
trackData <- data.frame()
surveyRoutesData <- data.frame()

for (scenario in scenarios) {
  mss <- getMSS(scenario, nSurveyRoutes=500)
  study <- mss$study
  tracks <- study$loadTracks(iteration=iterations[i])
  intersections <- tracks$countIntersections(surveyRoutes=mss$surveyRoutes, save=F)

  
  tracks$tracks <- subset(tracks$tracks, year==2001 & yday<59)
  x <- tracks$toGGDF()
  x$scenario <- scenario
  x$observation <- F
  
  intersections$tracks$tracks <- subset(intersections$tracks$tracks, year==2001)
  y <- intersections$tracks$toGGDF()
  y$scenario <- scenario
  y$observation <- T
  levels(y$group) <- paste(levels(y$group), "2")
  trackData <- rbind(trackData, x, y)
  
  
  x <- intersections$surveyRoutes$toGGDF()
  x$scenario <- scenario    
  observedAt <- intersections$intersections$intersections[intersections$intersections$intersections$intersections > 0 & intersections$intersections$intersections$year == 2001,]$surveyRoute
  y <- data.frame(id=unique(x$id), observation=FALSE)
  if (length(observedAt) > 0) y[y$id %in% observedAt,]$observation <- TRUE
  x <- plyr::join(x, y, by="id")
  surveyRoutesData <- rbind(surveyRoutesData, x)
    
  
  #trackData$type <- "track"
  #surveyRoutesData$type <- "transect"
  #x <- rbind(trackData[,c("long","lat","order","piece","group","observation","type")], surveyRoutesData[,c("long","lat","order","piece","group","observation","type")])
  #x$colour <- factor(paste(x$type, x$observation))
  #ggplot(x, aes(long, lat, group=group, colour=colour)) + geom_path()

  
  i <- i + 1
}

trackData$scenario <- factor(trackData$scenario)
```

```{r figure-1}
#window <- c(3.375, 3.4, 6.9, 6.925)*1e6
window <- (c(3.425, 3.45, 6.95, 6.975)+c(-.01,.01,-.01,.01)*9)*1e6
habitatRaster <- crop(study$studyArea$habitat, extent(window))
z <- sampleRegular(habitatRaster, 10000, asRaster=TRUE)
habitatData <- as.data.frame(rasterToPoints(z))
#habitatData <- as.data.frame(rasterToPoints(habitatRaster))
colnames(habitatData) <- c("x","y","z")
habitatData$scenario <- factor("E", levels=scenarios)
habitatData2 <- habitatData
habitatData2$scenario <- factor("F", levels=scenarios)
habitatData <- rbind(habitatData, habitatData2)

habitatData$z <- factor(habitatData$z, levels=0:255)
col <- study$studyArea$habitat@legend@colortable
names(col) <- 0:255

p <- ggplot(habitatData) + geom_raster(aes(x, y, fill=z), alpha=.4) + scale_fill_manual(values=col) +
  geom_path(data=trackData, aes(long, lat, group=group, colour=observation), alpha=1, size=.3) +#, alpha=observation)) +
  scale_colour_manual(values=c("gray55","black")) + # scale_alpha_manual(values=c(.5,1)) + # gray40
  geom_path(data=surveyRoutesData, aes(long, lat, group=group), size=.3, colour="blue", alpha=.5) +
  coord_fixed(ratio=1, xlim=window[1:2], ylim=window[3:4]) +
  facet_wrap(~scenario) + #coord_equal()
  theme_raster(base_size=10) + theme(panel.border=element_rect(fill="transparent"))
#print(p)
#saveFigure(p, "manuscript-figure-1.png", width=8, height=5)
saveFigure(p, "manuscript-figure-1.png", width=17, height=15, dpi=200) # draft quality


# scale on the map in km
c((window[2]-window[1]), (window[4]-window[3]))/1000
```

```{r figure-1-separate, eval=FALSE}
getRaster <- function(habitatRaster, xlim, ylim, size=10000) {
  x <- crop(habitatRaster, extent(c(xlim, ylim)))
  y <- sampleRegular(x, size=size, asRaster=TRUE)
  habitatData <- as.data.frame(rasterToPoints(y))
  colnames(habitatData) <- c("x","y","z")
  habitatData$z <- factor(habitatData$z, levels=0:255)
  col <- habitatRaster@legend@colortable
  names(col) <- 0:255
  return(habitatData)
}

getPanel <- function(scenario, xlim=c(3.375,3.4)*1e6, ylim=c(6.9,6.925)*1e6, habitatRaster, trackData, surveyRoutesData) {
  s <- scenario
  p <- if (!missing(habitatRaster)) {
    habitatData <- getRaster(habitatRaster=habitatRaster, xlim=xlim, ylim=ylim)
    ggplot(habitatData) + geom_raster(aes(x, y, fill=z)) + scale_fill_manual(values=col) +
      geom_path(data=subset(trackData, scenario==s), aes(long, lat, group=group, colour=observation))
  }
  else {
     ggplot(subset(trackData, scenario==s)) +
       geom_path(aes(long, lat, group=group, colour=observation))
  }
  
  p <- p + scale_colour_manual(values=c("gray40","black")) +
    geom_path(data=subset(surveyRoutesData, scenario==s), aes(long, lat, group=group)) +
    coord_fixed(ratio=1, xlim=xlim, ylim=ylim) +
    theme_raster(base_size=10, panel.border=element_rect(fill="transparent"), plot.title=element_text(size=12)) +
    ggtitle(s)

  return(p)
}

library(gridExtra)

p1 <- getPanel(scenario="A", trackData=trackData, surveyRoutesData=surveyRoutesData)
p2 <- getPanel(scenario="B", trackData=trackData, surveyRoutesData=surveyRoutesData)
p3 <- getPanel(scenario="C", trackData=trackData, surveyRoutesData=surveyRoutesData)
p4 <- getPanel(scenario="D", trackData=trackData, surveyRoutesData=surveyRoutesData)
p5 <- getPanel(scenario="E", habitatRaster=study$studyArea$habitat, trackData=trackData, surveyRoutesData=surveyRoutesData)
p6 <- getPanel(scenario="F", habitatRaster=study$studyArea$habitat, trackData=trackData, surveyRoutesData=surveyRoutesData)
p <- arrangeGrob(p1, p2, p3, p4, p5, p6, ncol=3, nrow=2)
saveFigure(p, "manuscript-figure-1.png")
```


```{r, eval=F}
#x<-data.frame(scenario="C", iteration=as.integer(3), stringsAsFactors=F)
modelName <- modelNames[2]
x<-data.frame(scenario="A", iteration=as.integer(10), stringsAsFactors=F)
study <- getStudy(scenario=x$scenario)
estimates <- study$getModel(modelName=modelName, iteration=x$iteration)
estimates$modelName <- modelName
estimates <- study$loadEstimates(estimates)
intersections <- study$loadIntersections(iteration=x$iteration)
head(subset(intersections$intersections@data, intersections>0), 20)
head(subset(estimates$data, intersections>0), 20)


model <- SimulatedSmoothModelTemporal(study=study, iteration=as.integer(1))
params <- list(family="nbinomial", offsetScale=1000^2, timeModel="ar1")
intersections <- study$loadIntersections(iteration = model$iteration)
model$setup(intersections = intersections, params = params)
model$estimate()

head(subset(model$data, intersections>0), 20)
head(subset(intersections$intersections@data, intersections>0), 20)


./count_intersections.sh ~/git/RParallelScreen/ A 1 1 1
./estimate.sh ~/git/RParallelScreen/ A 1 1 SmoothModel-nbinomial-ar1

./estimate.sh ~/git/RParallelScreen/ A 1 1 FMPModel

```

```{r figure-2-init}
getSurveyRouteLocations = function(scenarios, modelName, iterations, years) {
  ddply(data.frame(scenario=scenarios, iteration=iterations, stringsAsFactors=FALSE), .(scenario, iteration), function(x, modelName, years) {
    message("Scenario = ", x$scenario, ", iteration = ", x$iteration)
    study <- getStudy(scenario=x$scenario)
    estimates <- study$getModel(modelName=modelName, iteration=x$iteration) 
    estimates$modelName <- modelName
    estimates <- study$loadEstimates(estimates)
    z <- cbind(estimates$getUnscaledObservationCoordinates(), estimates$data)
    surveyRoutes <- subset(z, year %in% years, select=c(x,y,intersections))
    surveyRoutes$intersections <- surveyRoutes$intersections > 0
    surveyRoutes$Scenario <- x$scenario
    surveyRoutes$Iteration <- x$iteration
    return(surveyRoutes)
  }, modelName=modelName, years=years)
}

#x<-data.frame(scenario="C", iteration=as.integer(3), stringsAsFactors=F)
getAgentLocations = function(scenarios, modelName, iterations, years) {
  ddply(data.frame(scenario=scenarios, iteration=iterations, stringsAsFactors=FALSE), .(scenario, iteration), function(x, modelName, years) {

    #study <- getStudy(scenario=x$scenario)
    #intersections <- study$loadIntersections(iteration=x$iteration)
    #observationTracks <- SimulatedTracks$new(study=study, iteration=x$iteration)
    #observationTracks$loadTracks(fileName=observationTracks$getObservationTracksFileName(), addColumns=TRUE)
    # TODO: use observation tracks ^^^^
    
    
    
    study <- getStudy(scenario=x$scenario)
    tracks <- study$loadTracks(iteration=x$iteration)
    tracks$tracks <- subset(tracks$tracks, year %in% years & yday<59)
    intersections <- study$loadIntersections(iteration=x$iteration)
    
    # The observation day has not been recorded, ouch... just randomize a day from the 60 days track
    observedBursts <- aaply(intersections$intersectionsMatrix, 2, function(x) if (any(x>0)) TRUE else FALSE)
    #observationTracks <- tracks$randomizeObservationDayTracks(days=1)
    observationTracks <- tracks
    
    #d_ply(observationTracks$tracks, .(id, year, burst), function(x) {
    #  with(x[1,], message(id, " ", year, " ", burst))
    #})
    
    # Return mean location of the unobserved agents
    a <- ddply(observationTracks$tracks, .(id, year, burst), function(x, observedBursts) {
      name <- with(x[1,], paste(id, year, burst))
      if (observedBursts[name] == FALSE) return(data.frame(x=mean(x$x), y=mean(x$y), year=x$year[1]))
      #if (observedBursts[name] == FALSE) return(data.frame(x=x$x, y=x$y, year=x$year))
      NULL
    }, observedBursts=observedBursts)[,c("x","y","year")]
    a$Observed <- F
    
    # But for the observed agents we know the location, which is the transect
    index <- intersections$intersections$intersections > 0 & intersections$intersections$year %in% years
    b <- if (all(index == FALSE)) data.frame() else {
      x <- intersections$intersections[index,]
      y <- data.frame(coordinates(x), year=x$year)
      y$Observed <- T
      y
    }
    
    agentLocations <- rbind(a, b)
    agentLocations$Scenario <- x$scenario
    agentLocations$Model <- x$modelName
    
    return(agentLocations)
  }, modelName=modelName, years=years)
}

getEstimatedDensity = function(scenarios, modelName, iterations, year, sd=FALSE, log=FALSE) {
  ddply(data.frame(scenario=scenarios, year=rep(year, length(scenarios)), iteration=iterations, stringsAsFactors=FALSE), .(scenario, iteration), function(x, modelName, sd) {
    message("Scenario = ", x$scenario, ", iteration = ", x$iteration)
    study <- getStudy(scenario=x$scenario)
    estimates <- study$getModel(modelName=modelName, iteration=x$iteration)
    estimates$modelName <- modelName
    estimates <- study$loadEstimates(estimates)
    estimates$collectEstimates()
    
    studyArea <- FinlandStudyArea$new(context=context)$setup(tolerance=0.001)
    
    estimates$data <- subset(estimates$data, year == x$year)
    #if (log) estimates$data$fittedMean <- log(estimates$data$fittedMean)
    density <- estimates$getPopulationDensityInterpolate(getSD=sd, maskPolygon=studyArea$boundary)
    density <- if (sd) density$sd else density$mean
    if (is.null(density) || maxValue(density$rasterStack[[1]]) > 1) stop("Estimation failed.")
    density <- as.data.frame(density$rasterStack[[1]], xy=T)
    density$Scenario <- x$scenario
    density$Iteration <- x$iteration
    density$Model <- modelName
    density$Year <- x$year

    return(density)
  }, modelName=modelName, sd=sd)
}
```

```{r figure-2}
study <- getStudy(scenario="A")
limits <- extent(study$studyArea$boundary)
iterations <- as.integer(c(1,6,3,2,5,31))
year <- 2010
yearLayer <- paste0("X", year)
surveyRoutes <- getSurveyRouteLocations(scenarios=scenarios, modelName=modelNames[1], iterations=iterations, years=year)
#surveyRoutes <- rbind(surveyRoutes[surveyRoutes$intersections == FALSE,], surveyRoutes[surveyRoutes$intersections == TRUE,])
agents <- getAgentLocations(scenarios=scenarios, modelName=modelNames[1], iterations=iterations, years=year)
densities <- getEstimatedDensity(scenarios=scenarios, modelName=modelNames[1], iterations=iterations, year=year, sd=F, log=F)
# TODO: do not use scaling??
#densitiesScaled <- ddply(densities, .(scenario), function(x, yearLayer) { x[,yearLayer] <- scale(x[,yearLayer]); return(x) }, yearLayer=yearLayer)

# Scale density to 1/km^2
densitiesScaled <- ddply(densities, .(scenario), function(x, yearLayer, weight, logTrans) {
  x[,yearLayer] <- x[,yearLayer] * weight
  if (logTrans) x[,yearLayer] <- log(x[,yearLayer])
  return(x)
}, yearLayer=yearLayer, weight=1 / (prod(res(study$getTemplateRaster())) / 1000^2), logTrans=F)

#library(directlabels)

p <- ggplot(densitiesScaled) +
  geom_raster(aes_string(x="x", y="y", fill=yearLayer)) +
  stat_contour(aes_string(x="x", y="y", z=yearLayer, colour=yearLayer), size=0.1)
#p <- direct.label(p)
p <- p + scale_fill_gradientn(colours=terrain.colors(100), na.value="transparent",
                       guide=guide_legend(title=expression(paste("Population density ", (individuals/km^2)))), trans="log10",
                       #breaks=c(10^-4.5, 10^-4, 10^-3.5, 10^-3, 10^-2.5),
                       breaks=trans_breaks("log10", function(x) 10^x),
                       #labels=c(expression(10^-4.5), expression(10^-4.0), expression(10^-3.5), expression(10^-3.0), expression(10^-2.5)), limits=c(10^-4.5, 10^-2.5)
                       labels=trans_format("log10", math_format(10^.x))
                       ) +
  geom_path(data=boundaryDF, aes(long, lat, group=group), colour="darkgreen") +
  geom_point(data=agents, aes(x, y, colour=Observed), size=1.3, colour="white") +
  geom_point(data=agents, aes(x, y, colour=Observed), size=1) + scale_color_manual(values=c("darkgray", "black"), guide=FALSE) +
  scale_x_continuous(limits=c(limits@xmin, limits@xmax), expand=c(0.01,0.01)) +
  scale_y_continuous(limits=c(limits@ymin, limits@ymax), expand=c(0.01,0.01)) +
  facet_grid(~scenario) + coord_equal() + theme_raster(base_size=10) +
  theme(legend.position="bottom", legend.margin=unit(-2, units="line"),
        plot.margin=unit(c(-.5, 0, 0, -.5), units="line"))
#p <- direct.label(p)
saveFigure(p, "manuscript-figure-2a.png", width=17, height=7.2, dpi=200) # draft quality
saveFigure(p, "manuscript-figure-2a.pdf", width=17, height=7.2, dpi=300)


###

gridTemplate <- raster(extent(study$studyArea$boundary), nrows=12, ncols=6, crs=study$studyArea$proj4string)
gridTemplate@extent@xmax <- gridTemplate@extent@xmin + dim(gridTemplate)[2] * 100 * 1e3
gridTemplate@extent@ymax <- gridTemplate@extent@ymin + dim(gridTemplate)[1] * 100 * 1e3

p <- ggplot(boundaryDF) + geom_path(aes(long, lat, group=group), colour="grey") +
  geom_point(data=surveyRoutes, aes(x, y, colour=intersections), size=1) + scale_color_manual(values=c("darkgrey", "black")) +
  scale_x_continuous(breaks=seq(gridTemplate@extent@xmin, gridTemplate@extent@xmax, 1e5), expand=c(0.01,0.01)) +
  scale_y_continuous(breaks=seq(gridTemplate@extent@ymin, gridTemplate@extent@ymax, 1e5), expand=c(0.01,0.01)) +
  facet_grid(~scenario) + theme_raster(base_size=10) + coord_equal() +
  theme(panel.grid.major=element_line(colour="grey"), plot.margin=unit(c(0, 0, 0, -.5), units="line"))
saveFigure(p, "manuscript-figure-2b.png", width=17, height=6.7, dpi=200) # draft quality
saveFigure(p, "manuscript-figure-2b.pdf", width=17, height=6.7, dpi=300)
```

```{r figure-3-init}
getIntersections <- function(scenarios) {
  study <- getStudy(scenario="A")
  validation <- Validation(study=study)
  intersections <- validation$getValidationTemporalIntersections(scenarios=scenarios)
  intersections$Year <- intersections$year
  intersections
}

getPopulationSizes <- function(scenarios, modelNames, populationSizeCutoff=Inf) {
  study <- getStudy(scenario="A") # Get study object, scenario doesn't matter
  validation <- Validation(study=study, populationSizeCutoff=populationSizeCutoff)
  populationSizes <- validation$getValidationTemporalPopulationSizes(scenarios=scenarios, modelNames=modelNames)
  #validation$summarizePopulationSize(populationSizes)  
}

cutoffPopulationSizes <- function(populationSizes, cutoff=c(0,Inf)) subset(populationSizes, cutoff[1] <= Estimated & Estimated <= cutoff[2])

getMeanPopulationSizes <- function(populationSizes) {
  library(plyr)
  meanPopulationSizes <- ddply(populationSizes, .(scenario, modelName), function(x) {
    x <- data.frame(True=mean(x$Observed), Estimated=mean(x$Estimated), Scenario=x$scenario[1])
    if (is.infinite(x$True)) x$True <- NA
    if (is.infinite(x$Estimated)) x$Estimated <- NA
    return(x)
  })
  return(meanPopulationSizes)
}

getLogPopulationSizes <- function(populationSizes) {
  logPopulationSizes <- populationSizes
  logPopulationSizes$Observed <- log10(logPopulationSizes$Observed + 1)
  logPopulationSizes$Estimated <- log10(logPopulationSizes$Estimated + 1)
  return(logPopulationSizes)
}
```

```{r figure-3-init-2}
populationSizes <- getPopulationSizes(scenarios=scenarios, modelNames=modelNames[c(1,3,4,5)])
populationSizes2000 <- getPopulationSizes(scenarios=paste0(scenarios, "combined"), modelNames=modelNames[c(1,3,4,5)])
populationSizes10Days <- getPopulationSizes(scenarios=paste0(scenarios, "10days"), modelNames=modelNames[c(1,3,4,5)])

cutoff <- c(1,1000)

meanPopulationSizes  <- getMeanPopulationSizes(cutoffPopulationSizes(populationSizes, cutoff))
logPopulationSizes <- getLogPopulationSizes(cutoffPopulationSizes(populationSizes, cutoff))
logMeanPopulationSizes  <- getMeanPopulationSizes(logPopulationSizes)

meanPopulationSizes2000  <- getMeanPopulationSizes(cutoffPopulationSizes(populationSizes2000, 10*cutoff))
logPopulationSizes2000 <- getLogPopulationSizes(cutoffPopulationSizes(populationSizes2000, 10*cutoff))
logMeanPopulationSizes2000  <- getMeanPopulationSizes(logPopulationSizes2000)

meanPopulationSizes10Days  <- getMeanPopulationSizes(cutoffPopulationSizes(populationSizes10Days, cutoff))
logPopulationSizes10Days <- getLogPopulationSizes(cutoffPopulationSizes(populationSizes10Days, cutoff))
logMeanPopulationSizes10Days  <- getMeanPopulationSizes(logPopulationSizes10Days)
```

```{r figure-3abc}
plotLogPopulationSize <- function(size, modelName, case, xlim, ylim) {
  library(ggplot2)
  library(scales)
  library(grid)
  
  size$Scenario <- prettyScenario(size$Scenario)
  meanSize <- getMeanPopulationSizes(size)
  meanSize$Scenario <- prettyScenario(meanSize$Scenario)
  
  p <- ggplot(size, aes(Observed, Estimated, colour=modelName)) +
    geom_point(size=1, colour="darkgray", alpha=.5) +
    geom_abline(colour="black", linetype="longdash") + 
    geom_point(data=meanSize, aes(True, Estimated), size=2, shape=15, colour="black")

  #if (!any(abs(size$Estimated) == Inf)) p <- p + geom_smooth(method="lm", se=F, fullrange=T, colour="black")
  ls <- ddply(size, .(Scenario), function(x) if (!any(abs(x$Estimated) == Inf)) coef(lm(Estimated~Observed, x)) else c(NA,NA))
  p <- p + geom_abline(data=ls, aes(intercept=`(Intercept)`, slope=Observed))
  
  p <- p + facet_wrap(~Scenario) +
    #scale_x_continuous(limits=xlim, labels=trans_format("identity", math_format(10^.x))) +
    #scale_y_continuous(limits=ylim, labels=trans_format("identity", math_format(10^.x))) +
    scale_x_continuous(limits=xlim, labels=trans_format("identity", math_format(.x))) +
    scale_y_continuous(limits=ylim, labels=trans_format("identity", math_format(.x))) +
    xlab(expression(paste(Log[10], " true population size"))) + ylab(expression(paste(Log[10], " estimated population size"))) + ggtitle(paste("Case:", case, " Model:", prettyModelName(modelName[1]))) +
    theme_minimal(base_size=10) + theme(panel.border=element_rect(fill="transparent"),
                                        plot.title=element_text(size=10),
                                        plot.margin=unit(c(0, 0.2, 0, 0), units="line"), #top, right, bottom, and left margins
                                        legend.margin=unit(0, units="line"),
                                        panel.margin=unit(0, units="line"))

  return(p)
}

#modelNames <- modelNames[c(2:4,1)]

xlim <- log10(c(50,1200)); ylim <- xlim
p <- plotLogPopulationSize(subset(logPopulationSizes, modelName==modelNames[1]), modelName=modelNames[1], "1", xlim=xlim, ylim=ylim)
saveFigure(p, "manuscript-figure-3a1.png")
saveFigure(p, "manuscript-figure-3a1.pdf", dpi=300)
p <- plotLogPopulationSize(subset(logPopulationSizes, modelName==modelNames[3]), modelName=modelNames[3], "1", xlim=xlim, ylim=ylim)
saveFigure(p, "manuscript-figure-3a2.png")
saveFigure(p, "manuscript-figure-3a2.pdf", dpi=300)
p <- plotLogPopulationSize(subset(logPopulationSizes, modelName==modelNames[4]), modelName=modelNames[4], "1", xlim=xlim, ylim=ylim)
saveFigure(p, "manuscript-figure-3a3.png")
saveFigure(p, "manuscript-figure-3a3.pdf", dpi=300)
p <- plotLogPopulationSize(subset(logPopulationSizes, modelName==modelNames[5]), modelName=modelNames[5], "1", xlim=xlim, ylim=ylim)
saveFigure(p, "manuscript-figure-3a4.png")
saveFigure(p, "manuscript-figure-3a4.pdf", dpi=300)

xlim <- log10(c(500,4000)); ylim <- xlim
p <- plotLogPopulationSize(subset(logPopulationSizes2000, modelName==modelNames[1]), modelName=modelNames[1], "2", xlim=xlim, ylim=ylim)
saveFigure(p, "manuscript-figure-3b1.png")
saveFigure(p, "manuscript-figure-3b1.pdf", dpi=300)
p <- plotLogPopulationSize(subset(logPopulationSizes2000, modelName==modelNames[3]), modelName=modelNames[3], "2", xlim=xlim, ylim=ylim)
saveFigure(p, "manuscript-figure-3b2.png")
saveFigure(p, "manuscript-figure-3b2.pdf", dpi=300)
p <- plotLogPopulationSize(subset(logPopulationSizes2000, modelName==modelNames[4]), modelName=modelNames[4], "2", xlim=xlim, ylim=ylim)
saveFigure(p, "manuscript-figure-3b3.png")
saveFigure(p, "manuscript-figure-3b3.pdf", dpi=300)
p <- plotLogPopulationSize(subset(logPopulationSizes2000, modelName==modelNames[5]), modelName=modelNames[5], "2", xlim=xlim, ylim=ylim)
saveFigure(p, "manuscript-figure-3b4.png")
saveFigure(p, "manuscript-figure-3b4.pdf", dpi=300)

xlim <- log10(c(5,1200)); ylim <- xlim
p <- plotLogPopulationSize(subset(logPopulationSizes10Days, modelName==modelNames[1]), modelName=modelNames[1], "3", xlim=xlim, ylim=ylim)
saveFigure(p, "manuscript-figure-3c1.png")
saveFigure(p, "manuscript-figure-3c1.pdf", dpi=300)
p <- plotLogPopulationSize(subset(logPopulationSizes10Days, modelName==modelNames[3]), modelName=modelNames[3], "3", xlim=xlim, ylim=ylim)
saveFigure(p, "manuscript-figure-3c2.png")
saveFigure(p, "manuscript-figure-3c2.pdf", dpi=300)
p <- plotLogPopulationSize(subset(logPopulationSizes10Days, modelName==modelNames[4]), modelName=modelNames[4], "3", xlim=xlim, ylim=ylim)
saveFigure(p, "manuscript-figure-3c3.png")
saveFigure(p, "manuscript-figure-3c3.pdf", dpi=300)
p <- plotLogPopulationSize(subset(logPopulationSizes10Days, modelName==modelNames[5]), modelName=modelNames[5], "3", xlim=xlim, ylim=ylim)
saveFigure(p, "manuscript-figure-3c4.png")
saveFigure(p, "manuscript-figure-3c4.pdf", dpi=300)
```

```{r figure-3sample}
xlim <- log10(c(10,800)); ylim <- xlim
logPopulationSizesSample <- subset(logPopulationSizes, scenario == "A")
logPopulationSizesSample$modelName <- prettyModelName(logPopulationSizesSample$modelName)
logPopulationSizesSample <- rbind(
  subset(logPopulationSizesSample, modelName=="ST"),
  subset(logPopulationSizesSample, modelName=="T1"),
  subset(logPopulationSizesSample, modelName=="T2"),
  subset(logPopulationSizesSample, modelName=="FMP"))

#p <- plotLogPopulationSize(subset(logPopulationSizesSample, modelName==modelNames[c(1,3,4)]), modelName=modelNames[c(1,3,4)], "a", xlim=xlim, ylim=ylim)

plotLogPopulationSizeSample <- function(size, modelName, case, xlim, ylim) {
  library(ggplot2)
  library(scales)  
  size$Scenario <- prettyScenario(size$Scenario)
  meanSize <- getMeanPopulationSizes(size)
  meanSize$Scenario <- prettyScenario(meanSize$Scenario)
  
  p <- ggplot(size, aes(Observed, Estimated, colour=modelName)) +
    geom_point(size=1, colour="darkgray", alpha=.5) +
    geom_abline(colour="black", linetype="longdash") + 
    geom_point(data=meanSize, aes(True, Estimated), size=2, shape=15, colour="black")

  #if (!any(abs(size$Estimated) == Inf)) p <- p + geom_smooth(method="lm", se=F, fullrange=T, colour="black")
  ls <- ddply(size, .(modelName), function(x) if (!any(abs(x$Estimated) == Inf)) coef(lm(Estimated~Observed, x)) else c(NA,NA))
  p <- p + geom_abline(data=ls, aes(intercept=`(Intercept)`, slope=Observed))
  
  p <- p + facet_wrap(~modelName) +
    scale_x_continuous(limits=xlim, labels=trans_format("identity", math_format(10^.x))) +
    scale_y_continuous(limits=ylim, labels=trans_format("identity", math_format(10^.x))) +
    xlab("True population size") + ylab("Estimated population size") +
    theme_minimal(base_size=10) + theme(panel.border=element_rect(fill="transparent"),
                                        plot.title=element_text(size=10),
                                        plot.margin=unit(c(0, 0.1, 0, 0), units="line"), #top, right, bottom, and left margins
                                        legend.margin=unit(0, units="line"),
                                        panel.margin=unit(0, units="line"))

  return(p)
}

p <- plotLogPopulationSizeSample(subset(logPopulationSizesSample, modelName==c("ST","T1","T2","FMP")), modelName=c("ST","T1","T2","FMP"), "a", xlim=xlim, ylim=ylim)
saveFigure(p, "manuscript-figure-3sample.png", height=7.87*2/3) # draft quality
saveFigure(p, "manuscript-figure-3sample.pdf", height=7.87*2/3, dpi=300)
```

```{r table-1abc}
getPopulationSizesTable <- function(populationSizes, meanPopulationSizes, overEstimate, full=F, file, ...) {
  library(plyr)
  x <- ddply(populationSizes, .(Scenario, modelName), function(x, overEstimate) {
    failed <- (1 - nrow(cutoffPopulationSizes(x, overEstimate)) / nrow(x)) * 100
      #(sum(x$Estimated < overEstimate[1] | x$Estimated > overEstimate[2]) / nrow(x)) * 100)
    x <- cutoffPopulationSizes(x, overEstimate)
    #subset(x, Estimated <= overEstimate)
    #if (x$modelName[1] == "FMPModel") failed <- NA
    #if (any(abs(x$Estimated) == Inf)) return(data.frame(Intercept=NA, Slope=NA, SlopeSD=NA, R2=NA, Failed=failed, EstTrue=NA, EstTrueSD=NA, EstTrueMin=NA, EstTrueMax=NA, N=NA))
    y <- lm(Estimated~Observed, x)
    prop.mean <- mean(log(x$Estimated/x$Observed))
    prop.sd <- sd(log(x$Estimated/x$Observed))
    prop.min <- quantile(log(x$Estimated/x$Observed), .025)
    prop.max <- quantile(log(x$Estimated/x$Observed), .975)
    slope.sd <- coef(summary(y))[2,2]
    return(data.frame(Intercept=coef(y)[1], Slope=coef(y)[2], SlopeSD=slope.sd, R2=summary(y)$r.squared, EstTrue=prop.mean, EstTrueSD=prop.sd, EstTrueMin=prop.min, EstTrueMax=prop.max, Failed=failed, N=nrow(x)))
  }, overEstimate=overEstimate)
  
  y <- unique(meanPopulationSizes)
  y$Scenario <- y$scenario
  z <- plyr::join(x, y)
  z$Model <- prettyModelName(z$modelName)
  z$Scenario <- prettyScenario(z$Scenario)
  if (full) return(z)
  
  return(z)
}

table1 <- getPopulationSizesTable(populationSizes, meanPopulationSizes, overEstimate=cutoff)
logTable1 <- getPopulationSizesTable(logPopulationSizes, logMeanPopulationSizes, overEstimate=log10(cutoff+1))
logTable1$Failed <- table1$Failed

table2 <- getPopulationSizesTable(populationSizes2000, meanPopulationSizes2000, overEstimate=10*cutoff)
logTable2 <- getPopulationSizesTable(logPopulationSizes2000, logMeanPopulationSizes2000, overEstimate=log10(10*cutoff+1))
logTable2$Failed <- table2$Failed

table3 <- getPopulationSizesTable(populationSizes10Days, meanPopulationSizes10Days, overEstimate=cutoff)
logTable3 <- getPopulationSizesTable(logPopulationSizes10Days, logMeanPopulationSizes10Days, overEstimate=log10(cutoff+1))
logTable3$Failed <- table3$Failed

subset(logTable1, Model != "VT")
subset(logTable2, Model != "VT")
subset(logTable3, Model != "VT")


writeTable <- function(df, filename, context) {
  library(ReporteRs)
  doc <- docx()
  flextable <- FlexTable(df)
  addFlexTable(doc, flextable)
  dir <- normalizePath(context$figuresDirectory)
  writeDoc(doc, file=file.path(dir, filename))
}

plotPopulationSizesTable <- function(logTable) {
  library(reshape2)
  facet_labeller <- function(variable, value) {
    measured <- list(Slope=expression(beta), R2=expression(R^2), EstTrue=expression(alpha), Failed="Failed (%)")
    print(paste0(variable,"=",value))
    if (variable=="variable") return(measured[value])
    if (variable=="Case") return(paste("Case", value))
  }
  x <- melt(logTable, id.vars=c("Scenario", "Model", "Case"), measure.vars=c("Slope", "R2", "EstTrue", "Failed"))
  bestFit <- data.frame(variable=unique(x$variable), y=c(1, 1, 0, 0))
  errorBars <- x
  errorBars$value <- NA
  errorBars$value[errorBars$variable=="Slope"] <- logTable$Slope
  errorBars$qmin[errorBars$variable=="Slope"] <- logTable$Slope-logTable$SlopeSD
  errorBars$qmax[errorBars$variable=="Slope"] <- logTable$Slope+logTable$SlopeSD
  errorBars$value[errorBars$variable=="EstTrue"] <- logTable$EstTrue
  errorBars$qmin[errorBars$variable=="EstTrue"] <- logTable$EstTrueMin
  errorBars$qmax[errorBars$variable=="EstTrue"] <- logTable$EstTrueMax
  
  p <- ggplot(x, aes(Scenario, value, group=Model)) +
    geom_hline(data=bestFit, aes(yintercept=y), color="darkgray") + 
    geom_errorbar(data=errorBars, aes(Scenario, group=Model, ymax=qmax, ymin=qmin), position=position_dodge(width=.7), colour="darkgray") +
    geom_point(aes(shape=Model), position=position_dodge(width=.7)) +
    facet_grid(variable~Case, scales="free_y", labeller=facet_labeller) + ylab("") +
    theme_minimal(base_size=10) + theme(panel.border=element_rect(fill="transparent"), legend.title=element_text(size=10),
                                        legend.position="bottom",
                                        strip.text.x=element_text(size=10), strip.text.y=element_text(size=10),
                                        plot.margin=unit(c(0, 0, -.5, -.5), units="line"),
                                        legend.margin=unit(0, units="line"))# , legend.key=element_rect(fill="transparent"))
  return(p)
}

logTable1$Case <- "1"
logTable2$Case <- "2"
logTable3$Case <- "3"
logTable <- rbind(subset(logTable1, Model != "VT"), subset(logTable2, Model != "VT"), subset(logTable3, Model != "VT"))
p <- plotPopulationSizesTable(logTable)
saveFigure(p, "manuscript-figure-3.png", width=17, height=17, dpi=200) # draft quality
saveFigure(p, "manuscript-figure-3.pdf", width=17, height=17, dpi=300)

logTablePretty <- logTable
logTablePretty$Slope <- round(logTablePretty$Slope, 2)
logTablePretty$R2 <- round(logTablePretty$R2, 2)
logTablePretty$EstTrue <- round(logTablePretty$EstTrue, 2)
logTablePretty$EstTrueSD <- round(logTablePretty$EstTrueSD, 2)
logTablePretty$Failed <- round(logTablePretty$Failed, 0)
logTablePretty <- logTablePretty[,c("Case","Scenario","Model","Slope","R2","EstTrue","EstTrueSD","Failed")]
writeTable(subset(logTablePretty, Model != "VT"), "table-1.docx", context)

#writeTable(subset(logTable1, Model != "VT"), "table-1a.docx", context)
#writeTable(subset(logTable2, Model != "VT"), "table-1b.docx", context)
#writeTable(subset(logTable3, Model != "VT"), "table-1c.docx", context)
```

```{r table-2}
plotIntersectionPopulationSizeTable <- function(ratioTable) {
  library(reshape2)
  library(grid)
  x <- melt(ratioTable, id.vars=c("Scenario", "Case"), measure.vars=c("SizeCount"))
  errorBars <- x
  errorBars$value <- NA
  errorBars$value[errorBars$variable=="SizeCount"] <- ratioTable$SizeCount
  errorBars$qmin[errorBars$variable=="SizeCount"] <- ratioTable$SizeCountMin
  errorBars$qmax[errorBars$variable=="SizeCount"] <- ratioTable$SizeCountMax
  
  p <- ggplot(x, aes(Scenario, value, group=Case)) +
    geom_errorbar(data=errorBars, aes(Scenario, group=Case, ymax=qmax, ymin=qmin), position=position_dodge(width=.7), colour="darkgray") +
    geom_point(aes(shape=Case), position=position_dodge(width=0.7)) +
    ylab("Ratio") + #guides(shape=guide_legend()) +
    theme_minimal(base_size=10) + theme(panel.border=element_rect(fill="transparent"), legend.title=element_text(size=10),
                                        strip.text.y=element_text(size=10), legend.position="right",
                                        #legend.background=element_rect(fill="transparent"),
                                        plot.margin=unit(c(0.2, 0, 0, 0), units="line"),
                                        legend.margin=unit(-1, units="line"),
                                        panel.margin=unit(0, units="line"))# , legend.key=element_rect(fill="transparent"))
  return(p) 
}

intersections <- getIntersections(scenarios)
intersections2000 <- getIntersections(scenarios=paste0(scenarios, "combined"))
intersections10days <- getIntersections(scenarios=paste0(scenarios, "10days"))
intersections10days$intersections <- intersections10days$intersections / 10
intersectionsx <- plyr::join(populationSizes, intersections)
intersections2000x <- plyr::join(populationSizes2000, intersections2000)
intersections10daysx <- plyr::join(populationSizes10Days, intersections10days)

rer.stat <- function(x) data.frame(SizeCount=mean(x$intersections/x$Observed),
                                   SizeCountMin=quantile(x$intersections/x$Observed, 0.025),
                                   SizeCountMax=quantile(x$intersections/x$Observed, 0.975))
i <- ddply(intersectionsx, .(Scenario), rer.stat); i$Scenario=prettyScenario(i$Scenario); i$Case <- "1"
i2000 <- ddply(intersections2000x, .(Scenario), rer.stat); i2000$Scenario=prettyScenario(i2000$Scenario); i2000$Case <- "2"
i10days <- ddply(intersections10daysx, .(Scenario), rer.stat); i10days$Scenario=prettyScenario(i10days$Scenario); i10days$Case <- "3"

iall <- rbind(i, i2000, i10days)
p <- plotIntersectionPopulationSizeTable(iall)
saveFigure(p, "manuscript-figure-4x.png", height=7.87/2.5) # draft quality
saveFigure(p, "manuscript-figure-4x.pdf", height=7.87/2.5, dpi=300)

#writeTable(i, "table-2a.docx", context)
#writeTable(i2000, "table-2b.docx", context)
#writeTable(i10days, "table-2c.docx", context)
```

```{r figure-x-debug}
getTrueAndEstimatedCounts <- function(scenarios, modelNames, cutoff=c(-Inf,Inf)) {
  study <- getStudy(scenario="A")
  validation <- Validation(study=study, populationSizeCutoff=cutoff)
  counts <- validation$getCounts(scenarios=scenarios, modelNames=modelNames)
  counts <- ddply(counts, .(iteration), function(x) data.frame(Scenario=x$Scenario[1], Model=x$Model[1], True=mean(x$True), TrueSD=sd(x$True), Estimated=mean(x$Estimated), EstimatedSD=sd(x$Estimated)))
  return(counts)
}

c1 <- getTrueAndEstimatedCounts(scenarios=scenarios, modelNames=modelNames[c(1,3:5)])
c2 <- getTrueAndEstimatedCounts(scenarios=paste0(scenarios, "combined"), modelNames=modelNames[c(1,3:5)])
c3 <- getTrueAndEstimatedCounts(scenarios=paste0(scenarios, "10days"), modelNames=modelNames[c(1,3:5)])


```

```{r figure-4-init}
getPopulationCorrelations <- function(scenarios, modelNames, cutoff=c(-Inf,Inf)) {
  study <- getStudy(scenario="A")
  validation <- Validation(study=study, populationSizeCutoff=cutoff)
  populationCorrelations <- validation$getValidationSpatialPopulationSizes(scenarios=scenarios, modelNames=modelNames)
  return(populationCorrelations)
}

plotPopulationCorrelations <- function(populationCorrelations, case) {
  populationCorrelations$Scenario <- prettyScenario(populationCorrelations$Scenario)
  p <- ggplot(populationCorrelations, aes(True, Correlation)) + geom_point(size=1, colour="black") +
  facet_wrap(~Scenario, ncol=2) + xlab("True population size") +
  scale_y_continuous(limits=c(-1,1)) +
  ggtitle(paste("Case:", case)) +
  theme_minimal(base_size=10) + theme(panel.border=element_rect(fill="transparent"),
                                      plot.title=element_text(size=10),
                                      plot.margin=unit(c(0, 0, 0, 0), units="line"),
                                      panel.margin=unit(0, units="line"))#, axis.text.x=element_text(angle=45, hjust=.5, vjust=1))
  return(p)
}
```

```{r figure-4abc}
pc1 <- getPopulationCorrelations(scenarios=scenarios, modelNames=modelNames[1], cutoff=cutoff)
pc2 <- getPopulationCorrelations(scenarios=paste0(scenarios, "combined"), modelNames=modelNames[1], cutoff=cutoff)
pc3 <- getPopulationCorrelations(scenarios=paste0(scenarios, "10days"), modelNames=modelNames[1], cutoff=cutoff)

p1 <- plotPopulationCorrelations(pc1, "a")
saveFigure(p1, "manuscript-figure-4a.png")
p2 <- plotPopulationCorrelations(pc2, "b")
saveFigure(p2, "manuscript-figure-4b.png")
p3 <- plotPopulationCorrelations(pc3, "c")
saveFigure(p3, "manuscript-figure-4c.png")
```


```{r figure-5-init}
getCIProportions <- function(scenarios, modelNames, panel, scenarioNames, cutoff=Inf) {
  study <- getStudy(scenario="A")
  validation <- Validation(study=study, populationSizeCutoff=cutoff)
  a <- validation$getValidatedCredibilityIntervalsProportions(scenarios=scenarios, modelNames=modelNames)
  b <- validation$getValidatedCredibilityIntervalsProportions(scenarios=scenarios, modelNames=modelNames, probs=c(.25, .75), probsName="50%")
  credibilityIntervals <- rbind(a, b)
  credibilityIntervals$panel <- panel
  credibilityIntervals$scenario <- rep(scenarioNames, times=2, each=length(modelNames))
  return(credibilityIntervals)  
}

plotCIProportions <- function(credibilityIntervals) {
  modelLabels <- prettyModelName(unique(credibilityIntervals$modelName))
  credibilityIntervals$CI <- credibilityIntervals$Interval
  p <- ggplot(credibilityIntervals, aes(scenario, Proportion, shape=CI, colour=modelName)) +
    geom_hline(aes(yintercept=.5), color="grey90") +
    geom_hline(aes(yintercept=.95), color="grey90") +
    geom_point() +
    scale_shape_manual(values=c(16, 1)) +
    #scale_colour_manual("Model", values=c("black", "darkgray", "gray"), labels=modelLabels) +
    scale_colour_manual("Model", values=c("blue", "green", "red"), labels=modelLabels) +
    theme_minimal(base_size=10) + theme(panel.border=element_rect(fill="transparent")) +
    xlab("Scenario") + ylab("Proportion") +
    facet_wrap(~panel) + ylim(0, 1) +
    theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(),
          plot.margin=unit(c(0, 0, 0, 0), units="line"),
          #legend.background=element_rect(fill="transparent"),
          legend.margin=unit(-2, units="line"),
          panel.margin=unit(0, units="line"),
          legend.position="bottom",
          legend.box="horizontal")
  return(p)
}
p <- plotCIProportions(cip)
saveFigure(p, "manuscript-figure-5.png", height=7.87/2, dpi=200)
```

```{r figure-5abc}
cip1 <- getCIProportions(scenarios=scenarios, modelNames=modelNames[c(1,3,5)], panel="a", scenarioNames=scenarios, cutoff=cutoff)
cip2 <- getCIProportions(scenarios=paste0(scenarios, "combined"), modelNames=modelNames[c(1,3,5)], panel="b", scenarioNames=scenarios, cutoff=10*cutoff)
cip3 <- getCIProportions(scenarios=paste0(scenarios, "10days"), modelNames=modelNames[c(1,3,5)], panel="c", scenarioNames=scenarios, cutoff=cutoff)

cip <- subset(rbind(cip1, cip2, cip3), modelName != "SmoothModel-nbinomial-ar1")
p <- plotCIProportions(cip)
saveFigure(p, "manuscript-figure-5.png", height=7.87/2, dpi=200)
saveFigure(p, "manuscript-figure-5.pdf", height=7.87/2, dpi=300)
```
